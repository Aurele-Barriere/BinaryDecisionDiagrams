\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amsfonts,amssymb}
%\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}

\title{Binary Decision Diagrams}
\author{Aurèle Barrière \& Jérémy Thibault}
\date{6 mai 2016}


\def\question#1{\subsection*{Question #1}}
\def\phix{\varphi\uparrow\up{x}}
\def\ite{\textit{if-then-else}}
\def\P{\mathcal{P}}
\begin{document}
\maketitle
%\newpage

\section*{2\ BDD et forme normale \ite}

\question{1}

On a $\varphi\equiv\phix$ ssi pour toute valuation $V$, $V(\varphi) = V(\phix)$.

Soit $V$ une valuation quelconque. 

\paragraph{Supposons dans un premier temps $V(x) = 1$.} Comme $\phix = (x \wedge\varphi[1/x])\vee(\neg x\wedge\varphi[0/x])$ par définition, on a $V(\phix) = V(\varphi[1/x])$.

De même, comme $V(x) = 1$, on peut remplacer $x$ par 1 dans $\varphi$ sans changer $V(\varphi)$. En effet, par la définition inductive de la valuation d'une formule est un prolongement de la valuation sur les variables. Ainsi $V(\varphi)=V(\varphi[1/x])$ quand $V(x)=1)$.

Ainsi, dans ce cas, on a bien $V(\varphi) = V(\phix)$.

\paragraph{Désormais, supposons $V(x)=0$.} Cette fois-ci, $V(\phix) = V(\varphi[0/x])$.

De même, $V(\varphi) =  V(\varphi[0/x]) = V(\phix)$.

Ainsi, on a bien $\varphi\equiv\phix$.

\question{2}

On commence par montrer que toute formule peut être mise sous forme d'un arbre de décision.

En effet, soit $\varphi$ une formule faisant intervenir $n$ variables. On choisit un ordre sur ces variables que l'on nomme $x_1\dots x_n$.

On construit l'arbre de décision suivant : la racine est $x_1$, et le fils faible et fort de $x_i$ sont $x_{(i+1)}$ pour $i\in\{1\dots n-1\}$. Enfin les fils faibles et forts des noeuds étiquetés $x_n$ sont la valeur de $\varphi$ par la valuation qui à $x_i$ associe 1 si pour aboutir à cette feuille il faut prendre le fils fort à la $i$\up{ème} ligne, et 0 sinon.
%j'espere que c'est clair, c'est un truc tout ballot mais bon faut l'expliquer

On remarque également que tout sous-arbre d'un arbre de décision reste un arbre de décision. %utile pour l'hérédité

On va ensuite construire la forme \ite\ à partir de cet arbre de décision.

On va montrer que toute formule est équivalente à une formule \ite\ par récurrence sur le nombre de variables impliquées dans la formule.

On pose $\P(n)$ la propriété : ``Toute formule à $n$ variables est équivalente à une formule \ite''.

\paragraph{Initialisation : } 
Pour $n=0$, la formule est nécessairement constante quelle que soit la valuation, égale à 0 ou 1. On peut donc prendre la formule \ite\ 0 ou 1 correspondante.

Pour $n=1$, l'arbre de décision de la formule construit comme précédemment est ainsi réduit à 1 noeud interne (étiqueté par la variable utilisée, appelée $x$), dont les feuilles sont l'évaluation de $\varphi [ 1/x ]$ et $\varphi [ 0/x ]$ : 0 ou 1.

Dans ce cas, la formule est équivalent à $\phix$. C'est bien équivalent par la question précédente, et c'est bien une formule \ite\ car elle est formée à partir de l'opérateur \ite, des constantes 0 et 1 et que la formule test est $x$, une variable non niée.

\paragraph{Hérédité : }
On suppose $\P (n)$ vraie. Montrons $\P (n+1)$.

Soit $\varphi$ une formule utilisant $n+1$ variables $x_1\dots x_{n+1}$. Son arbre de décision construit comme précédemment a pour racine $x_1$, dont les fils faibles et forts sont les racines de sous-arbres de décision de hauteur $n$ (et de racine étiquetée par $x_2$). Ces deux sous-arbres représentent donc deux formule équivalentes à deux formes \ite\ par hypothèse de récurrence. Ces formules \ite\ seront notées $f$ et $F$,

On peut donc construire la formule \ite\ suivante : $x_1\rightarrow f,F$. C'est bien une formule \ite\ : $f$ et $F$ le sont, et on a utilisé l'opérateur \ite\ avec en formule test $x_1$, une variable non niée.

De plus, $\varphi$ est bien équivalent à cette formule, puisque dans les feuilles de $f$ on consière les valuations où $x_1 = 0$ et dans $F$ les valuations où $x_1 = 1$.


\paragraph{En conclusion} on a montré par récurrence $\P (n)\forall n\in\mathbb{N}$.

De plus, comme toute formule implique un nombre finie de variables (étant elle-même finie), alors toute formule est équivalente à une formule \ite.

\question{3}
Montrons l'existence et l'unicité, pour toute formule, d'un ROBDD équivalent.

Nous considérons une formule $f$.
\paragraph{Existence :}
Proposons un algorithme pour construire un ROBDD à partir d'une formule. Si cet algorithme est correct, alors on aura bien l'existence d'un ROBDD pour représenter toute formule.

Soit $f$ une formule, utilisant les variables $x_1\dots x_n$. Comme vu précédemment, on peut la mettre sous forme d'un arbre de décision ordonné, dont la racine est $x_1$, de fils $x_2$ \dots. 

On va alors transformer cet arbre de décision en un ROBDD. Il faut conserver l'ordre des variables et supprimmer tout couple de n\oe uds ayant même étiquette et mêmes fils, puis vérifier la propriété d'utilité.

On commence par fusionner toutes les feuilles 0, puis toutes les feuilles 1.

Ensuite, on regarde les n\oe uds étiquetés par $x_n$. Lorsque deux n\oe uds ont les mêmes fils, on les fusionne : on n'a plus qu'un seul n\oe uds, dont les fils sont ceux des deux n\oe uds initiaux, et vers lequel on fait pointer toutes les flèches qui pointaient vers les n\oe uds initiaux.

Ensuite, on regarde ceux étiquetés par $x_{n-1}$ et on fait la même chose.

On continue jusqu'à la racine.

On dispose donc d'un arbre de décision ordonné, tel qu'il n'existe plus deux n\oe uds ayant la même étiquette et les même fils. On a la propriété d'unicité. Cependant, il reste la condition d'utilité à vérifier.

On parcourt donc le graphe obtenu, et dès qu'on voit un n\oe ud dont les fils faibles et forts sont égaux, on le supprime et on fait pointer tout ce qui pointait vers lui vers son fils. Cela ne change pas le reste du graphe donc on peut le faire dans l'ordre que l'on veut, tant qu'il reste de tels n\oe uds. Cela ne change pas non plus l'ordre des variables.

Cependant, on a peut être compromis la condition d'unicité. On reparcourt alors en partant du bas pour supprimer les n\oe uds uniques. Puis on enlève encore les n\oe uds inutiles. Et on itère ces deux opérations jusqu'à stabilisation. 

L'algorithme termine puisque chacune des opérations fait diminuer strictement le nombre de n\oe uds et que le graphe initial est fini.
L'algorithme est correct puisqu'à la fin, on satisfait les deux conditions d'unicité et d'utilité : on a donc bien un ROBDD. Enfin, on n'a à aucun moment altéré la formule représntée par le graphe : toutes ces opérations sont licites sémantiquement. %bizarrement formulé?

Ainsi, pour toute formule, avec un ordre donné, il existe un ROBDD qui représente cette formule.

\paragraph{Unicité :} 
Nous allons montrer l'unicité par récurrence sur $n$, le nombre de variables impliqées dans une formule.

\subparagraph{Initialisation :}
$n = 0$ Lorsque la formule $f$ n'utilise aucune variable, alors elle est équivalente à 0 ou 1. L'unique ROBBD correspondant consiste donc en un seul noeud.

\subparagraph{Hérédité :}
Supposons l'unicité pour toute formule utilisant $n$ variables. Considérons maintenant la formule $f$ en utiilsant $n+1$, notées $x_1\dots x_{n+1}$.

On peut se trouver dans deux situations, selon si la variable $x_1$ est utile ou non dans la formule.

Si $x_1$ n'est pas utile, c'est-à-dire que $f[1/x_1]\equiv f[0/x_1]$, alors $x_1$ n'apparaît pas dans un ROBDD représentant $f$. Alors $f$ est une fonction de $n$ variables : $x_2\dots x_{n+1}$. Alors par hypothèse de récurrence, il existe un unique ROBDD représentant $f$.

Si la valuation de $x_1$ importe dans la valuation de $f$, alors il faut que $x_1$ apparaisse dans tout ROBDD représentant $f$. De plus, il faut qu'il apparaisse à la racine dans un ROBDD, sinon on rencontrerait une autre variable avant $x_1$ et on ne serait plus ordonné. On est de plus garantis que $x_1$ n'apparaît pas en dessous, puisqu'en dessous de la racine on a fixé la valeur de $x_1$.

Considérons alors deux ROBDDs représentant $f$ : $R_1$ et $R_2$. Ces deux ROBDD ont donc comme racine un n\oe ud étiqueté par $x_1$. Considérons désormais les fils de $x_1$ dans les deux arbres. Ces fils sont des ROBDD à $n$ variables, avec peut-être des n\oe uds communs.

Notons $l_1 = low(x_1)$ dans $R_1$,  $h_1 = high(x_1)$ dans $R_1$, $l_2 = low(x_1)$ dans $R_2$,  $h_2 = high(x_1)$ dans $R_2$.

Alors les graphes qui ont pour racines $l_1, l_2, h_1, h_2$ sont tous des ROBDD de formules à $n$ variables. Alors par hypothèse de récurrence ils sont uniques. Ainsi, comme $l_1$ et $l_2$ décrivent tous deux la formule $f[0/x_1]$, on a $l_1=l_2$. De même, $h_1=h_2$.

Cependant, dans $R_1$ et $R_2$, ces sous-ROBDD sont imbriqués : $l_1$ et $h_1$ partagent peut-être des n\oe uds.

Il faut donc montrer qu'il n'y a qu'une seule manière d'imbriquer deux ROBDD utilisant les mêmes variables dans le même ordre.
%c'est ca le point ``tricky''

Or c'est bien le cas : pour chaque variable $x_i$, $i\in[2\dots n]$ (ou pour chaque n\oe ud 0 et 1), lorsque deux noeuds étiquetés par $x_i$ ont les même fils dans un ROBDD comme dans l'autre, on les fusionne. Et on recommence tant qu'il existe de tels n\oe uds. Ce procédé ne peut conduire qu'à un seul ROBDD (quel que soit l'ordre dans lequel on considère les variables à fusionner), puisqu'une fusion ne modifie pas les graphes en dehors du n\oe ud fusionné, et ce procédé termine puisqu'il y a un nombre fini de n\oe uds. Enfin, ce procédé donne bien un ROBDD puisqu'il élimine tous les n\oe uds semblables.

Il n'y a donc bien qu'une seule manière d'imbriquer $l_1$ et $h_1$. Donc $R_1$ et $R_2$ sont identiques. Donc il existe un unique ROBDD pour décrire une formule à $n+1$ variables.

\subparagraph{Conclusion :} Ainsi, quel que soit le nombre de variables utilisées par une formule $f$, pour un ordre donné de ces variables il existe un unique ROBDD qui représente $f$.


\end{document}

